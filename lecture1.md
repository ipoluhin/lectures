# Лекция 1

Можно посмотреть пример в записи вебинара: [https://geekbrains.ru/lessons/66066](https://geekbrains.ru/lessons/66066)

- [NodeJS](https://github.com/Geekbrains-Frontend-Level-2/lectures/blob/master/lecture1.md#nodejs)
- [NPM](https://github.com/Geekbrains-Frontend-Level-2/lectures/blob/master/lecture1.md#npm)
- [Пишем сервер](https://github.com/Geekbrains-Frontend-Level-2/lectures/blob/master/lecture1.md#пишем-сервер)
- [Деплоим в интернет](https://github.com/Geekbrains-Frontend-Level-2/lectures/blob/master/lecture1.md#деплоим-в-интернет)
- [Полезные ссылки](https://github.com/Geekbrains-Frontend-Level-2/lectures/blob/master/lecture1.md#полезные-ссылки)

## NodeJS
Для работы понадобится собственно платформа ``Node.js``. Если вы ее еще не устанавливали, то вам придется это сделать. Скачать ``Node.js`` можно с сайта [https://nodejs.org/](https://nodejs.org/). Устанавливать советую версию LTS (то есть стабильную версию). Для пользователей линукса и MacOS это можно сделать через ``homebrew`` [(небольшой гайд)](https://www.dyclassroom.com/howto-mac/how-to-install-nodejs-and-npm-on-mac-using-homebrew).


#### Для чего нужно?
Итак, для чего нам вообще нужен ``Node.js``? Для того, чтобы наша система могла интерпретировать ``JavaScript``. Если я сейчас буду писать в терминале какие-то команды на JS, то меня система не поймет:
```bash
dzaytsev$ const a = ''
-bash: const: command not found
```
Для этого нужен интерпретатор, коим ``Node.js`` по своей сути и является.

После установки ``NodeJS``, нам достаточно ввести команду ``node`` в терминале, после чего систма будет интерпретировать введенные нами команды как язык ``JavaScript``:
```bash
dzaytsev$ node
> const a = 'hello'
> const b = 'world'

> const c = [a,b].join(' ')
> c
'hello world'

> const d = `${a} ${b}`
> d
'hello world'
```


#### Пример работы с NodeJS
Важно будет сообщить, что ``JavaScript``, который выполняется в браузере имеет ряд ограничений. Он не умеет работать с файловой системой, процессами (не может запустить стороннюю программу на компьютере), не умеет работать с сетью (помимо того ограниченного функционала, который предоставляет браузер) и прочие вещи. ``Node.js`` все это умеет.

Давайте рассмотрим пример работы с файловой системой. Напишем скрипт, который при запуске будет выводить содержимое файла, в котором он и находится.

Создадим файл ``script.js`` и поместим в него следующий код:
```javascript
// подключаем библиотеку для работы с файловой системой
const fs = require('fs')

// в переменную text считываем содержимое файла script.js (utf8 - кодировка файла)
const text = fs.readFileSync('script.js', 'utf8')

// выводим переменную text в консоль
console.log(text)
```
Сохраняем файл и запускаем его с помощью нашего интерпретатора. Делаем это командой:
```bash
node script.js
```
Если вы проделаете эти действия, то в ваш терминал выведется содержимое файла ``script.js``


## NPM
Далее, прежде чем мы создадим свой проект, я хочу вам рассказать о такой утилите в экосистеме ``Node.js`` как ``NPM``. Расшифровывается она как ``Node Package Manager``. Основное ее предназначение – это позволить использовать сторонние библиотеки в своем коде. Для того, чтобы их использовать достаточно выполнить команду
```bash
npm install <name>
```
Например, если бы ``fs`` из прошлого примера не был встроен в ``NodeJS``, то нам пришлось бы выполнить ``npm install fs``, и после этого уже использовать его так, как мы это сделали. Мы будем позже использовать эту команду для установки ``Vue``, ``Webpack`` и их зависимостей.

#### Создаем свой пакет

Также, можно создать свой модуль, давайте это сделаем. Для создания своего модуля надо зайти в директорию, где мы хотим это сделать и выполнить
```bash
npm init
```
После этого у нас в папке создастся файлик ``package.json``, который, можно сказать, является карточкой нашего проекта.
Его содержимое:
```javascript
{
  "name": "ZaitsevDmitry",
  "version": "1.0.0",
  "description": "Описание пакета",
  "scripts": {
    "start": "node script.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/Geekbrains-Frontend-Level-2/ZaitsevDmitry.git"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/Geekbrains-Frontend-Level-2/ZaitsevDmitry/issues"
  },
  "homepage": "https://github.com/Geekbrains-Frontend-Level-2/ZaitsevDmitry#readme"
}
```
Здесь есть информация о самом пакете, авторах, зависимостях (например после команды ``npm install`` в этот файлик бы вписалось имя установленного пакета).
Здесь же можно указывать скрипты для взаимодействия с нашим проектом. Например, мы хотим запустить тесты, запустить сборку проекта ли поднять сервер для разработки, пример которого мы напишем.


## Пишем сервер
``server.js``:
```javascript
// подключаем библиотеку для работы с http
const http = require('http')

/**
 * Создаем сервер
 * В качестве аргумента функции createServer передается функция-обработчик запроса
 * В нашем случае, на каждый запрос к серверу будет вызываться console.log('Hello World')
 */
const server = http.createServer((req, res) => {
  console.log('Hello Word')
})

// Вешаем наш сервер на порт 3000 (можно выбрать любой другой)
server.listen(3000)
// Выводим в консоль, что сервер стартовал
console.log('Server started')
```
После того как мы запустим сервер (``node server.js``). Мы можем открыть страницу в браузере ``localhost:3000``.
Однако, несмотря на то, что в консоле (где мы запустили сервер) выведется сообщение ``Hello World``, страница в браузере будет висеть в бесконечной загрузке. Это происходит потому, что мы никак не сообщили бразуеру, что смогли обработать запрос. Давайте это исправим.

У нас не даром в функции-обработчике есть 2 аргумента: ``req`` и ``res``.
> ``req`` - request - cодержит в себе всю информацию о запросе (урл, который запрашивается, иинформацию о клиенте: язык системы, браузер, ск оторого идет запросс и очень многое другое)

>``res`` - response - содержит в себе методы для создания ответа от сервера. Мы можем установить какие-нибудь заголовки (например надо ли нам кэшировать результат), можем установить cookie, ``status code`` ответа ([подробнее здесь](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%BA%D0%BE%D0%B4%D0%BE%D0%B2_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F_HTTP)). Таже здесь есть метод end(), который позволяет завершить обработку запроса и отослать клиенту результат

Давайте улучшим нашу функцию-оюработчик таким способом:
```javascript
const server = http.createServer((req, res) => {
  // выводим в консоль урл, который запрашивается браузером
  console.log(req.url)
  
  // отдаем браузеру строку Hello World!
  res.end('Hello Word!')
})
```
Теперь после рестарта сервера и перезагрузки страницы в браузере, у нас появится надпись ``Hello Word!``

#### Отдаем файлы
Пусть у нас есть файл ``index.html``, который лежит в папке ``public``. Для того, чтобы отправить этот файл при запросе ``localhost:3000``  нам надо прочитать этот файл и результат поместить в ``res.end()``. Считывать содержимое файла мы научились ранее, так что давайте воспользуемся нашими знаниями и сделаем то же самое:

```javascript
const http = require('http')
const fs = require('fs')

const server = http.createServer((req, res) => {
  console.log(req.url)
  const body = fs.readFileSync(`./public/index.html`)
  res.end(body)
})

server.listen(3000)
console.log('Server started')
```
Сейчас на каждый запрос будет отдаваться файл ``index.html``. Даже, если в самом ``index.html`` подключен файл стилей, то вместо стилей придет опять же файл ``index.html``. Чтобы такого не было, можно, например, воспользоваться переменной req.url и отдавать различный контент на основании ее содержимого. Попробуйте это сделать самостоятельно. Если не получится, можно посмотреть в вебинаре.

## Деплоим в интернет
Ранее, уже говорилось, что в файлике ``package.json`` есть секция ``scripts``, которая позволяет писать команды для взаимодействия с нашим проектом. Прежде всего давайте напишем команду запуска нашего приложения в этой секции. ``“start”: “node server.js”``. Этой командой можно воспользоваться, так же она будет использоваться платформой нашего хостинга, чтобы запустить наш сервер.

Также, стоит учесть то, что у себя мы запускали наш сервер на 3000 порту. Хостинг этого делать не позволяет и предоставляет свой собственный порт. Делается это через переменную окружения. Нам надо это учесть и давайте это сделаем:
```javascript
server.listen(process.env.PORT || 3000)
```
Глобальная переменная ``process`` содержит в себе переменную окружения ``env``, которая в свою очередь содержит переменную ``PORT``, через которую хостинг и будет передавать необходимое значение. Если переменная не установлена, то мы по прежнему используем 3000 порт.

Далее надо отправить результат нашей работы на удаленный репозиторий. Для этого воспользуемся командами
```bash
git add -A
git commit -m "Added webserver"
git push origin lesson1
```

Теперь все наши изменения доступны для просмотра непосроедственно на платформе github.com

#### Heroku
Чтобы развернуть свое приложение в интернетах, мы будем использовать бесплатный хостинг хероку. Этот хостинг поддерживает ``Node.js``, поэтому он нам безусловно подходит. План действий:
1)	Регистрируемся/заходим на [heroku.com](https://heroku.com/)
2)	Создаем приложение
3)	Заходим на вкладку ``deploy`` – выбираем ``connect github``
4)  Здесь же можно поставить галочку ``autodeploy`` - при каждом обновлении gihub репозитория, приложение будет автоматически задеплоено на хероку
5)	Выбираем свой проект и ветку, с актуальным заданием.
6)	Нажимаем ``deploy branch``
7) Профит, вы восхитительны


## Полезные ссылки
- [Методичка](https://docs.google.com/document/d/1wM8d-B5ddN2-lPIs8otLkgYO-0kmFYMwGSO6zGvX-EA/edit)
- [Редактор кода VS Code](https://code.visualstudio.com/)
- [NodeJS](https://nodejs.org/)
- [Немного о status code](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%BA%D0%BE%D0%B4%D0%BE%D0%B2_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F_HTTP)
- [Чуть больше о ES6](https://habr.com/ru/post/305900/)
- [Чуть больше и сложнее о Node.js для любознательных](https://habr.com/ru/company/ruvds/blog/422893/)
