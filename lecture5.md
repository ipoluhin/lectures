# Лекция 4

Можно посмотреть пример в записи вебинара: [https://geekbrains.ru/lessons/66069](https://geekbrains.ru/lessons/66070)

- [Введение в регулярные выражения](https://github.com/Geekbrains-Frontend-Level-2/lectures/blob/master/lecture5.md#что-такое-webpack)
- [Установка](https://github.com/Geekbrains-Frontend-Level-2/lectures/blob/master/lecture5.md#установка)
- [Конфигурирование](https://github.com/Geekbrains-Frontend-Level-2/lectures/blob/master/lecture5.md#конфигурирование)
- [Пишем кофигурацию для продакшн билда](https://github.com/Geekbrains-Frontend-Level-2/lectures/blob/master/lecture5.md#пишем-кофигурацию-для-продакшн-билда)
## Что такое Webpack
``Webpack`` — это инструмент, позволяющий скомпилировать, JavaScript модули в единый JS-файл.
``Webpack`` также известен как сборщик модулей.

Приложения, написанные на JavaScript, со временем становятся все сложнее и сложнее.
Становится не просто контролировать всю структуру зависимостей.
Такие инструменты, как сборщики, позволяют разработчикам упаковывать, компилировать и в целом организовывать все ресурсы, необходимые для проекта.
Можно использовать не только сторонние библиотеки, но и собственные файлы.
Подобная модульная система позволяет добиться лучшей организации проекта, так как получается, что он разбит на небольшие модули.

Давайте разобьем наш один большой и неудобный файл с классами на 5 отдельных файлов и попробуем все это скомпилировать вместе.
Давайте подключим все файлы в ``index.html``

```HTML
<script src="/js/renderer.js"></script>
<script src="/js/cartItem.js"></script>
<script src="/js/cart.js"></script>
<script src="/js/item.js"></script>
<script src="/js/itemList.js"></script>
<script src="/js/index.js"></script>
```

Теперь это все выглядит как-то так.
Хочу напомнить, что у нас сейчас простейшее приложение, состоящее из 5 классов.
В больших проектах таких классов/модулей может быть больше тысячи.
Подключать каждый файл таким образом – это очень неудобно.
Надо также помнить о зависимостях. Например я не могу поставить ``renderer`` в самый конец, так как от него зависят остальные классы.
Все ето держать в голове невозможно.

Здесь нам и поможет вебпак. С его помощью мы можем взаимодействовать между файлами подключая их непосредственно друг в друга, так как мы подключали библиотеку ``fs`` или ``http`` на сервере.

## Установка

Давайте посмотрим, что нам предлагает [документация](https://webpack.js.org/guides/getting-started/).
Для начала, нам надо установить вебпак. Если помните, mnто на первом занятии мы рассматривали утилиту ``npm``.
С ее помощью можно устанавливать сторонние библиотки в свой проект.
Для того, чтобы установить вебпак, нам необходимо воспользоваться следующей командой:

```bash
npm i webpack webpack-cli --save-dev
```

Это 2 разных пакета, они пишутся через пробел (никаких запятых ставить не надо). 

Мы можем увидеть, что в ``package.json`` у нас появились установленные пакеты, тут же указываются версии, которые установились.
Также появилась папка ``node_nodules``, в которой будут храниться все зависимости нашего проекта, а также файлик ``package-lock.json``, который также описывает все зависмости и подзависимости.
Если открыть папку ``node_modules``, то мы увидим не только 2 установленных пакета, а также все пакеты, от которых вебпак сам зависит.

С выходом вебпака 4 версии базовая настройка упростилась до невозможного. Сейчас нам достаточно прописать в наших файлах import и export:
```JavaScript
export default
import Renderer from ‘./renderer
```

После этого пропишем в package.json команду ``”build”: “webpack”``

Важно также помнить, что по умолчанию ``webpack`` может работать только с директорией ``src``, поэтому, давайте перенесем все наши ``.js`` файлы в новую директорию ``src``. Главный файл (точка входа) должен называться как ``index.js``.

Если мы запустим сборку (``npm run build``) мы увидим, что у нас создалась папка ``dist`` (так вебпак по умолчанию называет папку, куда сбрасывает результат своей работы).
В этой папке у нас образовался файл ``main.js``. В нем находится что-то совсем ничитабельное, однако можно найти куски кода, который писали мы с вами на прошлых занятиях.

Давайте поместим этот файл в папку ``public`` и подключим его в ``index.html``. Если мы это проделаем, то должно заработать так, как работало это раньше.

 ## Конфигурирование
 
То, что мы проделали выше – это самая база того, что умеет вебпак.
И даже эта база уже сильно упростит нам работу.
На самом деле вебпак можно конфигурировать как душе угодно, и если сделать это умело, потратив какое-то количество времени перед тем, как начать работать над проектом, можно заполучить очень сильного союзника.

Конфигурация для вебпака пишется в специальных конфиг-файлах.
Существует практика разделять конфигурационные файлы для разработки и для продакшн версии.

Например, когда мы хотим сбилдить наш проект для конечных пользователей - мы хотим максимально уменьшить размер нашего файла, разделить его на несколько отдельных чанков (маленьких файлов, которые увеличат скорость загрузки сайта), может быть захотим вырезать из кода все выводы в консоль, можно много придумать. 
Однако такая версия будет слишком сильно мешать в разработке.

Далее рассмотрим обе версии, которые будут по-разному собирать наш проект.

### Пишем кофигурацию для продакшн билда
Создадим файл ``webpack.config.js`` <- этот файл вебпак автоматически подхватит во воемя билда

Начнем мы с базовых понятий конфигурации ``webpack``

#### "Точка входа"

Переименуем ``index.js`` в ``main.js``. 
Если мы попытаемся сбилдить, то получим ошибку, что файл ``index.js`` не найден (помним замечание про структуру проекта?).
Но мы можем переопредлить точку входу с помощью следующей директивы:

```JavaScript
module.exports = {
  entry: './src/main.js'
}
```

Точку входа вебпак будет использовать для построения внутреннего графа зависимостей.
После ввода точки входа вебпак сможет понять, какие модули и библиотеки напрямую и не напрямую связываются.

Теперь, если мы запустим сборку, то она пройдет без ошибок.

#### "Точка выхода"

Теперь, допустим, нас не устраивает, что результат сборки кладется в папку ``dist``.
Мы можем это тоже изменить.
Я, например, хочу, чтобы результат сборки сразу помещался в папку ``public/js/``.
Давайте сделаем и это:

```JavaScript
const path = require('path')

module.exports = {
  entry: './src/main.js',
  output: {
    path: path.resolve(__dirname, 'public/js'), // путь, куда мы хотим положить файл с результатом сборки
    filename: 'script.js' // имя файла с результатом сборки
  }
}
```

Путь до файла должен быть абсолютным, поэтому нам пришлось воспользоваться конструкцией ``path.resolve(__dirname, 'public/js')``, которая вернет абсолютный путь до запрашиваемой папки.

#### Загрузчики

Давайте научим работать наш вебпак не только с файлами ``.js``, а еще с каким-нибудь типом файлов.
Допустим, я хочу напрямую из JS импортить ``.css`` файлы.
Пусть у меня будет какой-нибудь файл /src/css/uglify.css в котором я сделаю фон у каждого элемента красным.

``main.js``
```JavaScript
import './css/uglify.css';
```

Я его импорчу в ``main.js``, запускаю сборку и вылезает целая куча ошибок.
Для того, чтобы использовать ``css`` файлы надо их трансформировать в ``JS`` модули. Этим занимются так называемые лоадеры.

Описываются они в директиве

```JavaScript
module: {
  rules: [
  ]
}
```

В массиве ``rules`` будут содержаться объекты, которые отражают на себя файлы, с которыми мы хотим уметь работать.
Например. Мы хотим работать с типом файла ``css``

```JavaScript
module: {
  rules: [
    {
      test: /\.css$/,
      use: [
      ]
    }
  ]
}
```

В поле ``test`` мы указываем регулярное выражение, которое будет соответствовать типу файла. 
Далее, в поле ``use`` мы прописываем лоадеры, которые хотим использовать, чтобы научить вебпак обрабатывать это расширение. 
Например, для загрузки стилей нам надо использовать 2 лоадера: [css-loader](https://github.com/webpack-contrib/css-loader) и [style-loader](https://github.com/webpack-contrib/style-loader). 
Установим их через
```bash
npm i css-loader style-laoder --save-dev
```
После этого пропишем в конфигурации:

```JavaScript
module: {
  rules: [
    {
      test: /\.css$/,
      use: [
        { loader: 'style-loader' },
        { loader: 'css-loader' }
      ]
    }
  ]
}
```

``css-loader`` трансформирует стили в JS модуль, а ``style-loader`` внедряет эти стили на страницу (через тэг <style></style>). 
Выполняюься лоадеры в порядке снизу-вверх, относительно того, как они указаны в массиве ``use``.

> Вообще научить работать с лоадерами, мне кажется нельзя, здесь надо подходить методом проб и ошибок и досканального чтения документации. 
Зачастую надо потратить не мало времени, чтобы научить работать какой-то специфичный тип файла. 

Как-то так будет выглядеть наша простая сборка для продакшена :)

### Пишем кофигурацию билда для разработки

Давайте теперь напишем еще один конфиг, только теперь для разработки.

Создадим файл ``webpack.dev.config.js``

Основной особенностью девелопмент-конфигурации является применение изменений на лету. 
Если в проекте много модулей и компонентов, то сборка вебпаком не будет проходить за секунду. 
В зависимости от объема данных сборка может продолжаться даже больше минуты.

Если мы отлаживаем нашу программу, то будем очень часто вносить изменения. 
При каждой «пересборке» будет уходить куча времени. 
Эту проблему решает ``devServer``. С его помощью у нас не будет полностью пересобираться проект, а будет пересобираться только та часть, в которую внесли изменения.

> Более того, после внесения изменений страница без перезагрзки может подтянуть эти изменения.

Давайте и напишем этот девсервер.

Прежде всего, нам надо будет использовать стандартную конфигурацию. Там уже прописаны точка входа и лоадеры для стилей.

Чтобы совместить конфигурации необходимо воспользоваться специальной утилитой для вебпака – ``webpack-merge``. Установим ее.
```bash
npm i webpack-merge --save-dev
```

Воспользуемся ей в новой конфигурации:

```JavaScript
const merge = require('webpack-merge')
const base = require('./webpack.config') // наша базовая конфигурация, которую мы написали выше

module.exports = merge(base, {
  // тут будет конфигурация devServer
})
```

Теперь нам необходимо установить сам ``devServer``
```bash
npm i webpack-dev-server --save-dev
```

Теперь мы можем начать конфигурировать его. 

Важно понимать, что ``devServer`` не собирает наш проект в том виде, как мы уже видели. 
Здесь не будет создаваться файл ``main.js`` (то есть в файловой системе результат своей работы мы не увидим). 
Вместо того, чтобы создавать файл в папке ``public``, ``devServer`` поместит результат сборки в оперативную память и будет раздавать его как настоящий сервер.
Для этого нам надо указать, по какому адресу мы хотим видеть результат:

```JavaScript
const merge = require('webpack-merge')
const base = require('./webpack.config')

module.exports = merge(base, {
  // все настрйки devServer должны храниться в поле devServer
  devServer: {
    host: 'localhost',
    port: 8080,
  },
})

```

Чтобы проверить результат работы, нам нам надо создать команду в ``package.json``:
```json
"dev": "webpack-dev-server --config ./webpack.dev.config"
```
Здесь нам надо явно указать имя файла с конфигурацией.

Если мы запустим эту команду (``npm run dev``), то перейдя по адресу ``localhost:8080/script.js`` мы сможем увидеть результат сборки.

Так как у нас файл скрипта расположен по пути /js (и в ``index.html`` тоже подключается как ``/js/script.js``), то можем в конфигурации указать относительный путь до папки, от которой мы будем резолвиться, чтобы открыть резульатат сборки:
```
output: {
  publicPath: '/js',
},
```
Теперь результат сборки будет доступен по адресу ``localhost:8080/js/script.js``

Также, мы хотим, чтобы при открытии ``localhost:8080``, открывался наш проект:
```JavaScript
devServer: {
  contentBase: './public/', // говорит, что все, кромер результата сборки будет браться из данной папки
  host: 'localhost',
  port: 8080,
  },
```
Теперь по адресу ``localhost:8080`` у нас будет открываться полноценный проект. Более того, если мы изменим что-то в наших файлах, изменения автоматически подольются на страницу, без ее перезагрузки!

## Полезные ссылки
- [Документация](https://webpack.js.org/guides/getting-started/)
