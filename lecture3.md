# Лекция 3

Можно посмотреть пример в записи вебинара: [https://geekbrains.ru/lessons/66068](https://geekbrains.ru/lessons/66068)

- [Что такое асинхронность?](https://github.com/Geekbrains-Frontend-Level-2/lectures/blob/master/lecture3.md#асинхронность)
- [EventLoop](https://github.com/Geekbrains-Frontend-Level-2/lectures/blob/master/lecture3.md#eventloop)
- [Учимся работать с асинхронными функциями](https://github.com/Geekbrains-Frontend-Level-2/lectures/blob/master/lecture3.md#учимся-работать-с-асинхронными-функциями)
- [Коллбэки](https://github.com/Geekbrains-Frontend-Level-2/lectures/blob/master/lecture3.md#коллбэки)
- [Промисы](https://github.com/Geekbrains-Frontend-Level-2/lectures/blob/master/lecture3.md#промисы)
- [Работа с сетью](https://github.com/Geekbrains-Frontend-Level-2/lectures/blob/master/lecture3.md#работа-с-сетью)
- [Response](https://github.com/Geekbrains-Frontend-Level-2/lectures/blob/master/lecture3.md#response)

## Асинхронность

Сегодня мы рассмотрим такое понятие как асинхронность.

Представим, у нас есть какая-то программа, которая выполняет какие-то операции.
```JavaScript
const a = []

for (let i = 0; i < 100; i++) {
  a.push(i)
}

console.log(i)
```

Все действия выполняются последовательно:
1) Объявляется переменная массива
2) Последовательно (в цикле) вставляются в этот массив данные.
3) Массив выводится пользователю в консоль.

Все как обычно, ничего интересного.

Рассмотрим другой пример. 
В JavaScript есть такая функция как ``setTimeout`` [подробнее здесь](https://learn.javascript.ru/settimeout-setinterval).
Если вкратце, то она может установить задержку на выполнение какой-либо функции. Например.

```JavaScript
const main = () => {
  console.log('Main');

  setTimeout(() => {
    console.log('Delayed')
  }, 1000)
}

main()
```

Второй вывод ``Delayed`` будет произведен через 1 секунду после вывода ``Main`` в консоль.
Что будет, если поменять местами логи?

```JavaScript
const main = () => {
  setTimeout(() => {
    console.log('Delayed')
  }, 1000)
   
  console.log('Main');
}

main()
```

Будет ли вывод ``Main`` дожидаться, пока выполнится ``setTimeout``, или выведется вперед?
``Main`` выведется вперед, и лишь через секунду сработает функция из ``setTimeout``, в рамках которой выведется ``Delayed``. 

Даже, если в качестве задержки я установлю 0, то ``Delayed`` будет выведено в консоль вторым. 
Это и есть асинхронное событие. Оно было выдернуто из обычного потока и возвращено через секунду после этого.

Давайте рассмотрим, как эти вещи работают внутри.

## EventLoop
<img alt="Упрощенная модель EventLoop" src="https://github.com/Geekbrains-Frontend-Level-2/lectures/blob/master/images/1.jpg" width="500" />

То, что вы видите на изрображении сверху – это упрощенная модель EventLoop в JS.
На этой схеме можно показать, в какой последовательности вызываются функции. 
Давайте это рассмотрим на примере функции ``main()``, которую мы написали ранее.

#### Функция main() в рассмотрении EventLoop:

1) Сначала, вызов функции ``main()`` поместит ее в стэк.
<img alt="Упрощенная модель EventLoop" src="https://github.com/Geekbrains-Frontend-Level-2/lectures/blob/master/images/2.jpg" width="500" />

2) Далее браузер поместит в стэк первое выражение функции ``main()`` – функцию ``setTimeout`` с коллбэком, который выведет в консоль ``Delayed``
<img alt="Упрощенная модель EventLoop" src="https://github.com/Geekbrains-Frontend-Level-2/lectures/blob/master/images/3.jpg" width="500" />

3) Функция ``setTimeout`` использует апи браузера, чтобы задержать вызов коллбэка. На этом ее работа завершается, и она убирается из стэка. На ее место помещается следующее выражение – ``console.log(‘Main’)``.
<img alt="Упрощенная модель EventLoop" src="https://github.com/Geekbrains-Frontend-Level-2/lectures/blob/master/images/4.jpg" width="500" />

4) Время, на которое должен был задержаться вызов коллбэка – прошло, так как оно было равно 0. Коллбэк помещается в очередь ``Message Queue``. 
В то же время ``console.log(‘Main’)`` отработал и удаляется из стэка.
<img alt="Упрощенная модель EventLoop" src="https://github.com/Geekbrains-Frontend-Level-2/lectures/blob/master/images/5.jpg" width="500" />

5) ``main()`` больше не содержит выражений, поэтому тоже удаляется из стэка.
<img alt="Упрощенная модель EventLoop" src="https://github.com/Geekbrains-Frontend-Level-2/lectures/blob/master/images/6.jpg" width="500" />

6) Так как стэк пуст, браузер может посмотреть на ``Message Queue``, и если там есть выражения, то поместить их в стэк. Там находится наш коллбэк. Он и помещается в стэк. 
Важно, что ``Message Queue`` начинает слушать ТОЛЬКО ЕСЛИ СТЭК ПУСТОЙ!
<img alt="Упрощенная модель EventLoop" src="https://github.com/Geekbrains-Frontend-Level-2/lectures/blob/master/images/7.jpg" width="500" />

> Может возникнуть вопрос. А как так, мы же указали задержку в 0, но какие-то микросекунды все равно прошли? Так и есть. Время, которое указывается в качестве параметра в функции ``setTimeout``, является МИНИМАЛЬНЫМ, которое пройдет, прежде чем запустится коллбэк. Если у нас какие-то серьезные вычисления, то эта задержка может быть намного больше, вплоть до бесконечности (если у нас возник бесконечный цикл).

## Учимся работать с асинхронными функциями

Итак, рассмотрим теперь такой пример. Что выведется?

```JavaScript
let counter = 0

const asyncPlus = () => {
  setTimeout(() => {
    counter++
  }, 500)
}

const printCounter = () => {
  console.log(counter)
}

const main = () => {
  asyncPlus()
  printCounter()
}

main()
```

Выведется 0. Как это можно исправить, чтобы вывелась 1? Давайте рассмотрим пару способов.

### Коллбэки

Итак, первый способ – использование коллбэка. Вам этот способ уже должен быть знаком, но если нет, давайте его продемонстрируем:

```JavaScript
let counter = 0

/*
 * Передаем в функцию коллбэк, который вызовем после сложения
 * @param {Function} callback Функция, которая вызовется после сложения
 */
const asyncPlus = (callback) => {
  setTimeout(() => {
    counter++
    callback()
  }, 500)
}

const printCounter = () => {
  console.log(counter)
}

const main = () => {
  asyncPlus(printCounter) // Передаем функцию печати в качестве параметра
}

main()
```

### Промисы

Второй способ (более современный) использование объекта ``Promise``.
Есть очень крутая статья для тех, у кого возникли проблемы с тем, как работают промисы: [Статья на хабре](https://habr.com/ru/company/mailru/blog/269465/).
В рамках сегодняшнего урока я при всем желании не смогу ухватить все нюансы, поэтому очень хочу, чтобы вы с ней ознакомились.

Итак, что такое промисы? В принципе в методичке весьма неплохо дано определение:

``Promise`` – это специальный объект, который находится в одном из трёх состояний: ``pending`` («ожидание»), ``fulfilled`` («выполнено успешно») и ``rejected`` («выполнено с ошибкой»). 
При создании объекта в качестве аргумента в конструктор посылается функция, которая будет выполняться сразу, после создания объекта. 
У объекта Promise есть 2 метода для обработки завершения ожидания: ``then`` и ``catch``.
Метод ``then`` будет выполняться при успешном выполнении кода, который помещен в блок промиса. ``catch``, соответственно, будет вызываться, если произошла какая-то ошибка.

Рассмотрим пример:
```JavaScript
let counter = 0

const asyncPlus = () => {
  return new Promise(() => {
    setTimeout(() => {
      counter++
    }, 500)
  })
}

const printCounter = () => {
  console.log(counter)
}

const main = () => {
  asyncPlus()
    .then(printCounter)
}

main()
```

Что будет после выполнения данного кода? 
На самом деле - ничего.
 
Для того, чтобы сообщить объекту ``Promise``, что асинхронная функция успешно отработала, необходимо вызвать функции, которые передаются в качестве параметров к коллбэку. Эти функции обычно называют ``resolve()`` и ``reject()``. ``resolve()`` вызывают при успешной отработке, ``reject()`` – если что-то пошло не так. Вызов ``reject()`` влечет за собой отработку блока ``catch``.

```JavaScript
const asyncPlus = () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (typeof counter !== 'undefined') { // мы выше НЕ определили глобальную переменную counter
        counter++
        resolve()
      } else {
        reject('Counter should be defined') // выполнится данный кусок
      }
    }, 500)
  })
}

const printCounter = () => {
  console.log(counter)
}

const printError = e => {
  console.log(e)
}

const main = () => {
  asyncPlus()
    .then(printCounter)
    .catch(printError) // выведется ошибка
```

Важным также будет рассказать, что у нас есть возможность передавать значения в последующие обработчики ``then`` и ``catch``. Для этого надо необходимый параметр пробросить в качестве аргумента функции ``resolve()`` или ``reject()`` соответственно.

Сделаем переменную ``counter`` локальной. И передадим результат через аргумент ``resolve()``:

```JavaScript
const asyncPlus = (counter) => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (typeof counter !== 'undefined') {
        counter++
        resolve(counter)
      } else {
        reject('Counter should be defined')
      }
    }, 500)
  })
}

const printCounter = (counter) => {
  console.log(counter)
}

const printError = e => {
  console.log(e)
}

const main = () => {
  asyncPlus(0) // передаем значение счетчика непосредственно внутрь функции
    .then(result => { // здесь нам доступен результат, который мы прокинули в функцию resolve()
      printCounter(result) // результат передаем в функцию печати
    })
    .catch(printError)
}

main()
```

## Работа с сетью

Теперь, давайте поговорим о главной теме сегодняшнего занятия. О работе с сетью.

Нам пришлось немного остановиться на работе с асинхронностью, так как работа с сетью – это отличный пример этой асинхронности. 
Когда нам надо запросить какие-то данные, мы не будем же блокировать работу всего нашего скрипта, пока не пройдет соединение с каким-то сервером, медленно произойдет обмен данными и так далее. Разумеется. – нет. Вся работа с запросами идет в асинхронном режиме.

Итак. Если обратиться к методичке, то нам предлагается взглянуть на такой объект как ``XMLHTTPRequest``. Предлагаю ознакомиться с ним самим (на самом деле, прочитайте это в методичке). 
Здесь же мы рассмотри более современную и крутую штуку, которой сейчас пользуются в любом современном проекте – ``fetch``.

Подробнее о фетче можно почитать [тут](https://learn.javascript.ru/fetch) и [тут](https://habr.com/ru/post/252941/).

Основное отличие ``fetch`` от ``XMLHTTPRequest`` состоит в том, что ``fetch`` работает на ``Promise``, в то в ремя, как ``XMLHTTPRequest`` – на старых и скучных коллбэках. 
Также у ``fetch`` намного проще интерфейс, и отпадает необходимость помнить как устроено апи у ``XMLHTTPRequest``.

Итак, давайте сразу обратимся к нашему интернет-магазину. На момент завершения второго занятия, у нас список товаров – это захардкоженный массив. Предлагаю получать эти данные отдельным запросом, как-будто они лежат в базе данных. 
Разумеется у нас сейчас нет времени, чтобы писать полноценный веб-сервер, который работал бы с базой, однако мы можем создать файлик ``items.json``, в котором будет храниться наш список. 

``items.json``
```json
{
  "data": [
    { "title": "Shirt", "price": 150 },
    { "title": "Socks", "price": 50 },
    { "title": "Jacket", "price": 350 },
    { "title": "Shoes", "price": 250 }
  ]
}
```

Давайте в нашей функции ``fetchData`` вызовем запрос на сервер

```JavaScript
fetchData () {
  fetch('http://localhost:3000/database/items.json')
}
```

Если загрузим страницу магазина и перейдем во вкладку ``Network`` (в DevTools браузера), то увидим, что файл действительно прислался.
 
Давайте поподробнее здесь остановимся. 
В таком виде, как мы написали ``fetch`` – здесь он представляет собой простой ``GET`` запрос, который скачивает данные по предоставленному ``URL``. 
Однако, мы отлично можем конфигурировать запрос, если предоставим в качестве второго параметра объект с настройками. 
Например, мы можем установить ``HTTP`` метод, заголовки и передать данные.

Мы к этой теме вернемся еще на последнем занятии, но давайте рассмотрим, как бы выглядел запрос, который отправляет данные на сервер.

Для начала нам надо установить метод. Так как мы отправляем какие-то данные, значит мы должны воспользоваться методами ``POST``, ``PUT`` или ``DELETE``.
Если вкратце, то, когда нам надо добавить какие-то данные в базе, то мы используем ``POST``, если надо изменить их, то используем ``PUT``, если надо удалить – используем ``DELETE``. По мимо этих методов есть еще несколько других, таких как ``HEAD``, ``OPTIONS``, ``PATCH`` и прочие. Я при креплю к конспекту статью, в которой о них можно дополнительно почитать.
Подробнее предлагаю ознакомиться через методичку, а также почитайте [эту краткую статью](https://habr.com/ru/post/50147/) 

Итак, представим, что нам надо добавить товар в базу данных. Для этого воспользуемся методом ``POST``. Отправлять мы будем объект вида ``JSON``, что мы также указываем в заголовках. И соответственно сами ``JSON`` данные. Чтобы они были отправлены, их надо преобразовать в текстовое представление. Для этого можно воспользоваться встроенным интерфейсом объекта ``JSON`` – ``JSON.stringify()``

```JavaScript
// данные, которые хотим послать на сервер
const userDataToSend = {
  id: 123,
  name: 'Alex',
  age: 31,
}

const options = {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json;charset=utf-8'
  },
  body: JSON.stringify(data)
}

fetch('https://site.com/userapi', options) // пример POST запроса с использованием параметров

#### Response
Давайте вернемся непосредственно к нашей задаче. Мы знаем, что такой конструкцией:
```JavaScript
fetch('http://localhost:3000/database/items.json')
```
мы получили данные с сервера. Теперь их надо поместить в переменную ``_items``.

``fetch()`` нам вернет уже знакомый нам объект ``Promise``, в котором будет храниться ответ от сервера. То есть, мы спокойно можем вопользоваться методом ``then()`` и посмотреть, что же именно хранится в пришедших данных:

```JavaScript
fetch('http://localhost:3000/database/items.json')
  .then(res => {
    console.log(res)
  })
```

Итак, вот такие поля нам пришли в объекте ``res``

```
{
  type: "basic", // означает, что запрос сделан с того же ресурса, а не с какого-то чужого сайта
  url: http://localhost:3000/database/items.json, // урл, который запрашивали
  redirected: false, // был ли редирект на сервере
  status: 200, // http-статус ответа (помним же что они означают? если нет, то пройдите в 1 лекцию)
  ok: true, // собственно также статус, только в текстовом представлении
  statusText: "OK", // и еще раз :)
  headers: Headers {}, // заголовки ответа (выставляются на сервере)
  body: (...), // тут по сути хранятся данные, но они недоступны для просмотра
}
```

Чтобы вытащить данные, необходимо воспользоваться методом ``.json()``, который есть в объекте ``Response``:
```JavaScript
fetch('http://localhost:3000/database/items.json')
  .then(res => {
    console.log(res)
    console.log(res.json())
  })
```
Как мы видим, это опять объект ``Promise``, но у него уже есть данные.
> Кстати, ``json()`` можно вызвать только один раз. После этого поток с данными будем заморожен и недоступен для чтения.

Можно сделать сразу так:
```JavaScript
fetch('http://localhost:3000/database/items.json')
  .then(res => {
    console.log(res)
    res.json()
      .then(data => {
        console.log(data) // данные файла items.json
      })
    })
```
Но это некрасиво, потому что если мы каждый промис будем вызывать в обработчике другого промиса, то у нас выстроится очень большая вложенность.
Благо в промисах это очень легко разрешается. Мы можем передать значение промиса в другой ``then`` через возвращаемый параметр:
```JavaScript
fetch('http://localhost:3000/database/items.json')
  .then(res => {
    return res.json()
  })
  .then(res => {
    console.log(res)
  })
```
Так намного компактнее, красивее и в целом правильнее! Не так ли?

Теперь можем поместить данные в наш массив:
```JavaScript
fetchData () {
  fetch('http://localhost:3000/database/items.json')
    .then(res => {
      return res.json()
    })
    .then(res => {
      console.log(res) // данные items.json
      this._items = res.data.map(item => {
        return new Item(item)
      })
    })
}
```

Если мы сейчас запустим наш скрипт, то будет куча ошибок, так как у нас ``render()`` запустится до того, как выполнится запрос на сервер. 
Давайте это исправим. Лучше всего вернуть промис из ``fetchData()`` и в ``then()`` запустить ``render()``:

```JavaScript
// ...
constructor (root) {
  super(root)
  this.fetchData()
    .then(this.render.bind(this))
}
// ...
```

Теперь все заработает!
