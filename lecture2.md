# Лекция 2

Можно посмотреть пример в записи вебинара: [https://geekbrains.ru/lessons/66067](https://geekbrains.ru/lessons/66067)

- [OOP](https://github.com/Geekbrains-Frontend-Level-2/lectures/blob/master/lecture2.md#OOP)
- [Инкапсуляция, наследование, полиморфизм](https://github.com/Geekbrains-Frontend-Level-2/lectures/blob/master/lecture2.md#инкапсуляция-наследование-полиморфизм)
- [SET, GET](https://github.com/Geekbrains-Frontend-Level-2/lectures/blob/master/lecture2.md#set-get)
- [Context](https://github.com/Geekbrains-Frontend-Level-2/lectures/blob/master/lecture2.md#context)

## OOP
Сегодня мы поговорим об объектно-ориентированном подходе в целом, а также о классах и объектах в JavaScript.
Для начала, что вообще такое объекты и классы? Здесь можно провести аналогию с реальным миром.

#### Объект

Все что вы видите, по сути является объектом.  
Человек (``Human``), кошка (``Cat``), камень (``Stone``), компьютер (``Computer``) – это все объекты.

Каждый объект имеет какие-то свойства.
Например, у человека есть имя, у кошки – длина хвоста, у камня – его цвет, у компьютера – производитель.
```
Human
  name

Cat
  tailLength

Stone
  color

Computer
  factory
```

Также, у каждого объекта есть какой-то набор действий, которые он может совершить.

Человек может ходить и разговаривать, кошка – может спать и есть, камень просто существовать, компьютер – много чего умеет (например, включаться и выключаться).

```
Human
  name
  walk()
  talk()

Cat
  tailLength
  eat()
  sleep()

Stone
  color
  exist()

Computer
  factory
  powerOn()
  powerOff()
```

Это можно перенести в мир программирования.
Здесь объекты – по сути те же материальные вещи, только в виртуальном пространстве.
И у этих объектов, как и в реальном мире есть свои свойства и набор действий (которые принято называть методами).

#### Класс

С объектами разобрались. Что же тогда такое классы?

Я думаю, что здесь можно провести аналогию с чертежом, схемой какого-то конкретного объекта.
По сути - так оно есть.  
Класс – это способ описать некоторую сущность, задать какие у этой сущности могут быть свойства, и какие операции может проводить эта сущность.

То, что я написал выше, можно уже назвать классами для какого-то абстрактного языка программирования.
Тут есть название класса (ex. ``Cat``), свойства (ex. ``name``) и методы (ex. ``powerOn``).
Давайте теперь уйдем от понятия «абстрактный язык программирования» и напишем класс в ES6 стандарте JavaScript.

Давайте возьмем, например сущность в виде кошки.
```JavaScript
class Cat {
}
```

По сути, это уже и есть простейший класс.
Сейчас в нем нет никаких свойств и операций, однако, мы уже можем сделать от него объект. Для этого надо написать:
```JavaScript
const myCat = new Cat()
console.log(myCat)
```
Как мы видим, объект действительно создался, ошибок никаких нет, но он пустой:
```bash
Object {
}
```

Давайте дадим кошке имя, и укажем, что она может есть и спать.
```JavaScript
class Cat {
  name = 'Alice'

  eat () {
    console.log('Cat gonna eat')
  }

  sleep () {
    console.log('Zzzzzz')
  }
}
const MyCat = new Cat()

console.log(MyCat)
MyCat.eat()
MyCat.sleep()
```

Мы видим, что объект теперь имеет имя, а также он может есть и храпеть:
```bash
Object {
  name: "Alice"
}
"Cat gonna eat"
"Zzzzzz"
```

Плохо то, что сколько бы кошек у нас не было, все они будут кошкой-Алисой.
Было бы здорово, чтобы при создании новой кошки мы могли присвоить ей любое имя.
Разумеется, это возможно, если мы зададим функцию-конструктор.
Эта функция будет вызываться при создании объекта, и в ней мы можем инициализировать свойства.

```JavaScript
class Cat {
  name = ''

  constructor (name) {
    this.name = name
  }
}
```

> Кстати, всегда, когда обращаетесь к методам или свойствам в рамках класса, необходимо использовать ключевое слово ``this``.


## Инкапсуляция, наследование, полиморфизм

Дальше, прежде чем продолжим, я хочу опять остановиться на парадигме ООП в целом, не касаясь JavaScript.

#### ИНКАПСУЛЯЦИЯ

По сути, это свойство позволяет пользователю (под пользователем здесь имеем в виду программиста, пишущего код) не задумываться о том, как устроена функция, объект, модуль (все что угодно) внутри, а взаимодействовать с ними только посредством предоставленного интерфейса. То есть, если мы говорим об объектах и классах и вернемся к нашей кошке, то нам не важно, как оно устроено внутри. Мы просто можем заставить ее есть вызвав ПУБЛИЧНЫЙ метод eat().

Почему я акцентировал внимание именно на ПУБЛИЧНЫЙ? Потому что в парадигме ООП существуют такие понятия как ``публичный``, ``приватный`` и ``защищенный`` метод (или свойство).

> Публичными методами и свойствами могут пользоваться как внутри класса (при реализации функционала), так и извне (программистами при написании кода).

> Приватными методами и свойствами можно пользоваться только внутри класса. Они служат для внутренней логики нашего модуля и не должны быть видимыми для окружения.

> Также есть такой тип как «защищенный», или protected. Свойства и методы, определенные с таким типом, не могут быть доступны снаружи, но могут быть доступны внутри класса и внутри класса-потомка.

Здесь мы постепенно подходим к понятию «наследования», так что давайте разберемся, что такое класс-потомок.

#### НАСЛЕДОВАНИЕ

Наследование – механизм, который позволяет описать новый класс, на основе существующего.
Обратимся опять к нашей кошке. Я думаю, что можно выделить отдельный класс – домашний питомец ``Pet``. Тогда ``Pet`` – будет классом-родителем для ``Cat``, а ``Cat``, в свою очередь, будет классом-потомком для ``Pet``.
В класс-родитель мы можем (и должны) поместить все те свойства и методы, которые могут быть присущи всем домашним питомцам, а не только кошке. Например. Имя – может быть как у кошки, так и у любимой рыбки. Способность есть и спать – также. Все это можем вынести в класс Pet.

```JavaScript
class Pet {
  name = ''

  constructor (name) {
    this.name = name
  }

  eat () {
    console.log('Creature gonna eat')
  }

  sleep () {
    console.log('Zzzzzz')
  }
}
```

Что же остается нашей кошке? Давайте сделаем ей метод «гулять» (например, рыбка у нас может плавать, но гулять – нет, так что нельзя данный метод вынести в родителя)

```JavaScript
class Cat extends Pet {
  walk () {
    console.log('Cat is walking now')
  }
}
```

Однако, мы опять потеряли нашу уникальность питомца, так как сейчас отсутствует функция-конструктор у класса, который мы будем создавать. Чтобы нам прокинуть параметры в функцию-конструктор родителя, необходимо вызывать в нашем конструкции функцию ``super()``. Более того, всегда, когда мы делаем в дочернем классе функцию конструктор, мы обязаны вызвать ``super()``, даже если там не передаются какие-то аргументы:

```JavaScript
class Cat extends Pet {
  constructor (name) {
    super(name)
  }

  walk () {
    console.log('Cat is walking now')
  }
}
```

#### ПОЛИМОРФИЗМ

И последнее, с чем нам осталось разобраться – странное слово полиморфизм.

Официально определение звучит так:
> Классы с одинаковой спецификацией могут иметь различную реализацию.

Что же это значит. Представим, что в нашем родительском классе ``Pet`` есть функционал “подать голос” - ``voice()``.

```JavaScript
class Pet {
  voice () {
    console.log('')
  }
}
```

Просто выводим пустоту в консоль, так как непонятно, о каком животном идет речь, и какие звуки оно производит.

Сделаем 2 дочерних класса: ``Cat`` и ``Dog``, в которых переопределим метод ``voice()``.

```JavaScript
class Cat extends Pet {
  voice () {
    console.log('Meow')
  }
}

class Dog extends Pet {
  voice () {
    console.log('Wow')
  }
}
```

Теперь представим, что мы завели себе и кошку, и собаку, и они все решили привлечь наше внимание:

```JavaScript
const myCat = new Cat()
const myDog = new Dog()
const myPets = [myCat, myDog]
myPets.forEach(pet => {
  pet.voice()
})
```

Собственно, это и есть полиморфизм: в массиве у нас объекты животных.
У них у всех есть метод «голос», но при запуске скрипта, этот методы будут вести себя по-разному. Попробуйте и убедителсь сами :)


## SET-GET

Последнее, что я хотел бы рассказать о классах на сегодня – про сеттеры и геттеры.

Собственно геттеры и сеттеры позволяют читать и записывать свойства в классах. Предположим, что у нас есть какое-то приватное свойство у нашего класса. В JavaScript вообще нет как таковых приватных свойств (в отличие от того же ``TypeScript``), но есть общепринятое правило, что свойства и методы, которые не следует использовать вне класса надо называть с нижнего подчеркивания. Итак, пусть данным свойством будет имя животного:
```JavaScript
class Pet {
  _name = ''

  constructor (name) {
    this._name = name
  }
}
```

Давайте установим публичный геттер для имени:

```JavaScript
class Pet {
  _name = ''

  constructor (name) {
    this._name = name
  }

  get name () {
    return this._name
  }
}
```

Теперь, если мы создадим объект, то можем получить его имя.

```JavaScript
// Попробуем изменить имя:
const pet = new Pet('A')
console.log(pet.name)
pet.name = 'B'
console.log(pet.name)
```
Если запустить скрипт, то мы увидим, что оно не изменилось, так как мы не указали для ``name`` сеттер. Таким образом можно сделать свойство только для чтения. Давайте сделаем так, чтобы можно было в эту переменную писать. Как вы уже догадались, я думаю, надо написать сеттер:

```JavaScript
class Pet {
  _name = ''

  constructor (name) {
    this._name = name
  }

  get name () {
    return this._name
  }
  
  set name (v) {
    this._name = v
  }
}
```

Теперь, если мы проделаем предыдущий пример, мы увидим, что имя изменилось.

## Практика

Думаю, что теперь можно перенести полученные знания уже непосредственно на нашу работу.
Прежде чем писать классы, нам надо посмотреть на наше приложение и выявить в нем составные части – максимально декомпозировать его.
Такое первоначальное проектирование архитектуры очень важно на начальном этапе, чтобы в последствии не пришлось переделывать.


На что можно разделить предлагаемую страницу интернет-магазина? Важно отметить, что любой элемент, который у нас повторяется, или может быть переиспользован, следует выносить в отдельный модуль (в нашем случае в отдельный класс).

Исходя из сказанного, явно, что главным объектом на странице является карточка товара. Дальше, если смотреть выше, то у нас есть сам список товаров (их компоновка).  Этот элемент хоть визуально может и не видим, но его явно надо определить как отдельную сущность (со своей логикой). Также у нас есть картина, форма поиска, обратной связи и прочие элементы со своей логикой, которые можно выделить в отдельные классы.

Давайте попробуем реализовать классы карточки и списка соответсвенно.
Для начала – что будет общего у данных классов?
Оба данных класса будут выводить какие-то данные на страницу. Класс карточки – макет карточки, класс списка – сами карточки. Логика вставки информации на страницу в обоих случаях будет одинаковая, так что предлагаю ее вынести тоже в отдельный родительский класс - ``Renderer``

```JavaScript
class Renderer {
  constructor (root) {
    this._root = root
    this.prepareTemplate()
  }

  get root () {
    return this._root
  }

  get template () {
    return this._template
  }

  prepareTemplate () {
    this._template = document.createElement('div')
  }

  initTemplate () {
    if (!this._template) {
      return
    }
    return this._template.innerHTML = ''
  }

  render (primaryRoot) {
    if (primaryRoot) {
      this._root = primaryRoot
    }

    this.initTemplate()

    const { root, template } = this
    if (root) {
      root.appendChild(template)
    }
  }
}
```

Теперь, можем реализовать класс карточки

```JavaScript
class Item extends Renderer {
  constructor (data = {}, root) {
    super(root)
    this._data = data
  }

  initTemplate () {
    if (!this._template) {
      return
    }

    const { title, price } = this._data
    this._template.className = 'item'
    this._template.innerHTML = `
      <div class="item__img">
        <img src="https://lh3.googleusercontent.com/proxy/LVtomnf11uWKZuUfgO_JAJZb7pnqr0EpXlLK8J70E00DvhZgYdXzNKt93kSf00NrFhnAU0yg-rCkXP583Obg5jNMmj5eJG-s5NQWJo2_jIm2RAUPC2POF7RsS6dQwg" />
      </div>
      <div class="item__meta">Товар: <span>${title}</span></div>
      <div class="item__meta">Цена: <span>${price}</span></div>
    `
  }
}
```

Мы можем попробовать вывести карточку:

```JavaScript
const item = new Item(
  { title: 'Shirt', price: 150, },
  document.querySelector('main')
)
item.render()
```

> У нас в классе ``Item`` нет метода рендера, но он есть в родительском классе, поэтому мы спокойно можем им оперировать. Родительский класс render использует функцию ``initTemplate``, который переопределяется в дочернем классе и предоставляет верстку в переменную ``_template``.

Таким же способом можно сделать класс списка:

```JavaScript
class ItemList extends Renderer {
  constructor (root) {
    super(root)
    this.fetchData()
  }

  fetchData () {
    const items = [
      { title: 'Shirt', price: 150 },
      { title: 'Socks', price: 50 },
      { title: 'Jacket', price: 350 },
      { title: 'Shoes', price: 250 },
    ]

    this._items = items.map(item => {
      return new Item(item)
    })
  }

  get items () {
    return this._items
  }

  initTemplate () {
    if (!this._template) {
      return
    }

    this._template.className = 'items-list'
    this.items.forEach(item => item.render(this._template))
  }
}
```

## Context
Может возникнуть вопрос, а как обрабатывать всякие нажатия на кнопки, если такие у нас есть в наших шаблонах (или на карточку товара в принципе)?

В нашем случае у нас в переменной ``template``хранится DOM-элемент, на который можно навесить событие:
```JavaScript
class Item extends Renderer {
  constructor (data = {}, root) {
    super(root)
    this._data = data
  }
  
  onButtonClick () {
    console.log(this.__data)
  }

  initTemplate () {
    if (!this._template) {
      return
    }

    const { title, price } = this._data
    this._template.className = 'item'
    this._template.innerHTML = `
      <div class="item__img">
        <img src="https://lh3.googleusercontent.com/proxy/LVtomnf11uWKZuUfgO_JAJZb7pnqr0EpXlLK8J70E00DvhZgYdXzNKt93kSf00NrFhnAU0yg-rCkXP583Obg5jNMmj5eJG-s5NQWJo2_jIm2RAUPC2POF7RsS6dQwg" />
      </div>
      <div class="item__meta">Товар: <span>${title}</span></div>
      <div class="item__meta">Цена: <span>${price}</span></div>
      <button>Click me</button>
    `
    
    const cardButton = this.template.querySelector('button')
    cardButton.addEventListener('click', this.onButtonClick.bind(this))
  }
}
```

Обратите внимание на ``this.onButtonClick.bind(this)``
Данная конструкция позволяет нам передать в функцию onButtonClick контекст переменной ``this``.
Если этого не сделать, то как ни странно, после вызова обработчика, в методе ``onButtonClick``, ``this`` будет указывать не на объект класса, а на DOM элемент, с которого произошел вызов обработчика.

Пара хороших статей про this, call, bind, apply:  
- [Как работает this](https://medium.com/@stasonmars/%D0%BF%D0%BE%D0%B4%D1%80%D0%BE%D0%B1%D0%BD%D0%BE-%D0%BE-%D1%82%D0%BE%D0%BC-%D0%BA%D0%B0%D0%BA-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82-this-%D0%B2-javascript-a13b4b6ec9ac)
- [Различия в call, bind, apply](https://medium.com/@stasonmars/%D0%BF%D0%BE%D0%B4%D1%80%D0%BE%D0%B1%D0%BD%D0%BE-%D0%BE-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%B0%D1%85-apply-call-%D0%B8-bind-%D0%BD%D0%B5%D0%BE%D0%B1%D1%85%D0%BE%D0%B4%D0%B8%D0%BC%D1%8B%D1%85-%D0%BA%D0%B0%D0%B6%D0%B4%D0%BE%D0%BC%D1%83-javascript-%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%87%D0%B8%D0%BA%D1%83-ddd5f9b06290)

Если прочитаете, предлагаю попробовать написать свою реализацию функции bind:
```JavaScript
/**
 * @param {object} ctx - Переданное значение this
 * @param {function} func - Функция, к которой надо применить контекст
 */
const bind = (ctx, func) => {
  // ваша реализация (можно использовать call или apply)
}
```

Кто сможет - тому респет и уважение!
