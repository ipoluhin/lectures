# Лекция 4

Можно посмотреть пример в записи вебинара: [https://geekbrains.ru/lessons/66069](https://geekbrains.ru/lessons/66069)

- [Введение в регулярные выражения](https://github.com/Geekbrains-Frontend-Level-2/lectures/blob/master/lecture4.md#введение-в-регулярные-выражения)
- [Скобочная группа](https://github.com/Geekbrains-Frontend-Level-2/lectures/blob/master/lecture4.md#скобочная-группа)
- [Номер группы](https://github.com/Geekbrains-Frontend-Level-2/lectures/blob/master/lecture4.md#номер-группы)
- [Replace](https://github.com/Geekbrains-Frontend-Level-2/lectures/blob/master/lecture4.md#replace)
- [Полезные ссылки](https://github.com/Geekbrains-Frontend-Level-2/lectures/blob/master/lecture4.md#полезные-ссылки)

## Введение в регулярные выражения
Что такое вообще регулярные выражения, и для чего они нужны?

> Регулярное выражение – это некоторый шаблон, общее представление под которое может попадать целое множество строк.

Давайте рассмотрим пример.
```JavaScript
const text = 'I love JavaScript'
const re = /JavaScript/

const result = text.match(re)
console.log(result)
```
>Выведет ``JavaScript``. Если в строке нет вхождения, то вернется null.

Рассмотрим более сложный пример. Пусть мы хотим выбрать все языки программирования из строки, в которых есть слово Script
```JavaScript
const text = 'I love JavaScript and TypeScript'
const re = /[\S]+Script/g

const result = text.match(re)
console.log(result)
```
>Выведет ``JavaScript``, ``TypeScript``

Здесь мы воспользовались конструкциями:
 - ``[]`` - набор символов;
 - ``\S`` - любой непробельный символ;
 - ``+`` - квантификатор, который говорит, что символ перед ``+`` может повторяться 1 и более раз
 - флаг ``g`` (в конце строки) - данный флаг позволяет продолжить поиск, даже если вхождение найдено, так что можно найти несколько вхождений в строке

Таким образом, в найденные вхождения будут помещены все подстроки, заканчивающиеся на ``Script``, перед которыми стоит что-то, кроме пробелов.

Давайте рассмотрим пример, в котором нам в строке надо найти число.
```JavaScript
const text = '20000 leagues under the sea'
const re = /\d+/g

const result = text.match(re)
console.log(result)
```
> Выведет ``20000``
Здесь мы воспользовались ``\d`` - любая цифра и ``+`` - 1 и более раз

## Скобочная группа
Часть шаблона можно заключить в скобки ``(...)``. Это называется «скобочная группа».

У такого выделения есть два эффекта:
1. Позволяет поместить часть совпадения в отдельный массив.
2. Если установить квантификатор после скобок, то он будет применяться ко всему содержимому скобки, а не к одному символу.

```JavaScript
const text = '20000 leagues under the sea'
const re = /\d+(.*)/

const result = text.match(re)
console.log(result)
```
> Выведет ``20000 leagues under the sea`` (полное вхождение), ``leagues under the sea`` (то, что в скобках)

## Номер группы
К группе можно обратиться в шаблоне, используя ``\N``, где ``N`` – это номер группы. 
Чтобы было яснее, зачем это нужно, рассмотрим пример.

Необходимо найти строки в кавычках: либо одинарных ``'...'``, либо двойных ``"..."``. 
Можно попытаться добавить оба вида кавычек в квадратные скобки: ``['"](.*?)['"]``, но в таком случае будут находиться строки со смешанными кавычками, например ``"...'`` и ``'..."``. 
Это приведёт к ошибке, когда одна кавычка окажется внутри других, как в строке "It's a trap!"

Здесь нам и поможет обращение к группе:
```JavaScript
let text = `He said: "It's a trap"`;

let regexp = /(['"])(.*)\1/g;
const result = text.match(regexp)
console.log(result)
```
В данном случае ``\1`` указывает на уже найденную кавычку. То есть вторая кавычка будет ровно такой же, как и первая.

## Replace
С помощью регулярных выражений можно заметь подчасти строк. Делается это с помощью функции ``replace``

```JavaScript
const text = 'I love C++'
const result = text.replace(/C\++/, 'JavaScript')
console.log(result)
```
> Выведет ``I love JavaScript``

Кстати, не забываем экранировать символы, которые являются зарезервированными в регулярных выражениях. 
Например в примере выше, чтобы выделить ``C++``, нам пришлось заэкранировать первый ``+``.
Второй плюс здесь будет выступать квантификатором (вхождение 1 и более раз).

#### Для ситуаций, которые требуют «умных» замен, вторым аргументом может быть функция.
```JavaScript
text.replace(regexp, (match, p1, p2, ..., pn, offset, input, groups) => {
 /* some action */
 return ''
});
```
Функция будет вызываться для каждого совпадения, и её результат будет вставлен в качестве замены. 
Функция вызывается с аргументами 
```
1. match – найденное совпадение,
2. p1, p2, ..., pn – содержимое скобок (см. Скобочные группы).
3. offset – позиция, на которой найдено совпадение,
4. input – исходная строка,
5. groups – объект с содержимым именованных скобок (см. Скобочные группы).
```

Прекрасный пример - реализация RLE-сжатия ([Что это?](https://www.kv.by/archive/index2009421104.htm))
```JavaScript
const text = 'AAAADEEESSQQQQQQ';
const result = text.replace(/(.)\1+/g, (m, c) => c + m.length);
console.log(result)
```
> Выведет ``A4DE3S2Q6``

## Полезные ссылки
- [Методичка](https://docs.google.com/document/d/1iBoHMzsNTcndk5MAM0gPTZwebszeUDEVrTpWNz1bf98)
- [Поиграться с регулярками](https://regex101.com/)
- [СуперГайд](https://learn.javascript.ru/regular-expressions)
